# -*- coding: utf-8 -*-
"""Web_scarapping_prj.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UI4GpDNbual9QYueUzmEU8keDQ9QbvVD
"""

!pip install requests
!pip install beautifulsoup4

!pip install bs4

import requests
from  bs4 import BeautifulSoup
import pandas as pd

import time
search_element = "oppo"
flipkart_url = f"https://www.flipkart.com/search?q={search_element}"
# Using a common browser User-Agent to mimic a real user
headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"}

# Adding a delay to avoid overwhelming the server
time.sleep(2)

webpage=requests.get(flipkart_url,headers=headers)
webpage

print(webpage)

print(webpage.text)

web_res = BeautifulSoup(webpage.text, 'html.parser')
web_res

products = web_res.find_all("div", {'class':"cPHDOP col-12-12"})
len(products)

product = products[3]
product

product.div.div.div

product.div.div.div.a['href']

"https://www.flipkart.com" + product.div.div.div.a['href']

product_links = []
for product in products:
    try:
        link = "https://www.flipkart.com" + product.div.div.div.a['href']
        product_links.append(link)
    except:
        pass
print(product_links)
print(len(product_links))

import time
product_link = product_links[0]
headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"}

# Adding a delay before requesting the product page
time.sleep(2)

product_page = requests.get(product_link, headers=headers)
product_page

product_res = BeautifulSoup(product_page.text,'html.parser')
product_res

comments=product_res.find_all("div",{"class":"RcXBOT"})
len(comments)

comment=comments[0]
comment

comment.div.div.div

# Assuming the rating is within a div with a specific class.
# You NEED to replace 'YOUR_RATING_CLASS_NAME' with the actual class name
# you find by inspecting the webpage's HTML for the rating element.
rating_element = comment.find("div", {"class": "XQDdHH Ga3i8K"})

# Check if the rating element was found before trying to access its text
if rating_element:
    rating = rating_element.text
    print(rating)
else:
    print("Rating element not found for this comment.")

comment_header=comment.div.div.div.p.text
comment_header

# Assuming the comment body is within a div with the class 'ZmyHeo'
comment_body_element = comment.find("div", {"class": "ZmyHeo"})

# Check if the comment body element was found before trying to access its text
if comment_body_element:
    comment_body = comment_body_element.text
    print(comment_body)
else:
    print("Comment body element not found for this comment.")

product_link

# Assuming the author's name is within a p tag with the class '_2NsDsF AwS1CA'
author_element = comment.find("p", {"class": "_2NsDsF AwS1CA"})

# Check if the author element was found before trying to access its text
if author_element:
    author_name = author_element.text
    print(author_name)
else:
    print("Author name element not found for this comment.")

# Assuming the timestamp is within a p tag with the class '_2NsDsF'
timestamp_element = comment.find("p", {"class": "_2NsDsF", "id": False}) # Added id=False to avoid matching author's name if it also has _2NsDsF

# Check if the timestamp element was found before trying to access its text
if timestamp_element:
    timestamp = timestamp_element.text
    print(timestamp)
else:
    print("Timestamp element not found for this comment.")

# Assuming the location is within a p tag with the class 'MztJPv'
location_element = comment.find("p", {"class": "MztJPv"})

# Check if the location element was found before trying to access its text
if location_element:
    location = location_element.text
    print(location)
else:
    print("Location element not found for this comment.")

# Assuming the timestamp is the second p tag with class '_2NsDsF' within its parent div
# You might need to adjust the index [1] if the structure is different
timestamp_elements = comment.find_all("p", {"class": "_2NsDsF"})

# Check if there are at least two such elements before trying to access the second one
if len(timestamp_elements) > 1:
    timestamp = timestamp_elements[1].text
    print(timestamp)
else:
    print("Timestamp element not found or not in the expected position for this comment.")

# Assuming likes and dislikes are in span tags with class 'tl9VpF' within a div with class 'qhmk-f'
like_dislike_container = comment.find("div", {"class": "qhmk-f"})

if like_dislike_container:
    like_elements = like_dislike_container.find_all("span", {"class": "tl9VpF"})

    if len(like_elements) >= 2:
        likes = like_elements[0].text
        dislikes = like_elements[1].text
        print(f"Likes: {likes}")
        print(f"Dislikes: {dislikes}")
    else:
        print("Like or dislike elements not found in the expected structure.")
else:
    print("Like/dislike container not found for this comment.")

# Get the first comment from the list
if comments: # Check if the comments list is not empty
    comment = comments[0]

    rating = None
    comment_header = None
    comment_body = None
    author_name = None
    location = None
    timestamp = None
    likes = None
    dislikes = None

    # Extract Rating
    rating_element = comment.find("div", {"class": "XQDdHH Ga3i8K"})
    if rating_element:
        rating = rating_element.text

    # Extract Comment Header
    comment_header_element = comment.find("p", {"class": "z9E0IG"})
    if comment_header_element:
        comment_header = comment_header_element.text

    # Extract Comment Body
    comment_body_element = comment.find("div", {"class": "ZmyHeo"})
    if comment_body_element:
        comment_body = comment_body_element.text

    # Extract Author Name and Timestamp (assuming timestamp is the second p tag with class '_2NsDsF')
    author_timestamp_elements = comment.find_all("p", {"class": "_2NsDsF"})
    if len(author_timestamp_elements) > 0:
        author_name = author_timestamp_elements[0].text
    if len(author_timestamp_elements) > 1:
        timestamp = author_timestamp_elements[1].text

    # Extract Location
    location_element = comment.find("p", {"class": "MztJPv"})
    if location_element:
        location = location_element.text

    # Extract Likes and Dislikes
    like_dislike_container = comment.find("div", {"class": "qhmk-f"})
    if like_dislike_container:
        like_elements = like_dislike_container.find_all("span", {"class": "tl9VpF"})
        if len(like_elements) >= 2:
            likes = like_elements[0].text
            dislikes = like_elements[1].text

    # Store the details in a dictionary
    first_comment_details = {
        "Rating": rating,
        "Comment Header": comment_header,
        "Comment Body": comment_body,
        "Author": author_name,
        "Location": location,
        "Timestamp": timestamp,
        "Likes": likes,
        "Dislikes": dislikes
    }

    # Display the details
    print("Details for the first comment:")
    for key, value in first_comment_details.items():
        print(f"{key}: {value}")
else:
    print("No comments found to extract details from.")

comments_data = []

# Check if the comments list is not empty before iterating
if comments:
    for comment in comments:
        rating = None
        comment_header = None
        comment_body = None
        author_name = None
        location = None
        timestamp = None
        likes = None
        dislikes = None

        # Extract Rating
        rating_element = comment.find("div", {"class": "XQDdHH Ga3i8K"})
        if rating_element:
            rating = rating_element.text

        # Extract Comment Header
        comment_header_element = comment.find("p", {"class": "z9E0IG"})
        if comment_header_element:
            comment_header = comment_header_element.text

        # Extract Comment Body
        comment_body_element = comment.find("div", {"class": "ZmyHeo"})
        if comment_body_element:
            comment_body = comment_body_element.text

        # Extract Author Name and Timestamp (assuming timestamp is the second p tag with class '_2NsDsF')
        author_timestamp_elements = comment.find_all("p", {"class": "_2NsDsF"})
        if len(author_timestamp_elements) > 0:
            author_name = author_timestamp_elements[0].text
        if len(author_timestamp_elements) > 1:
            timestamp = author_timestamp_elements[1].text

        # Extract Location
        location_element = comment.find("p", {"class": "MztJPv"})
        if location_element:
            location = location_element.text

        # Extract Likes and Dislikes
        like_dislike_container = comment.find("div", {"class": "qhmk-f"})
        if like_dislike_container:
            like_elements = like_dislike_container.find_all("span", {"class": "tl9VpF"})
            if len(like_elements) >= 2:
                likes = like_elements[0].text
                dislikes = like_elements[1].text

        comments_data.append({
            "Rating": rating,
            "Comment Header": comment_header,
            "Comment Body": comment_body,
            "Author": author_name,
            "Location": location,
            "Timestamp": timestamp,
            "Likes": likes,
            "Dislikes": dislikes
        })

# Create a pandas DataFrame
    comments_df = pd.DataFrame(comments_data)
    display(comments_df)
else:
    print("No comments found to extract details from.")